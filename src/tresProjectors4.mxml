<?xml version="1.0" encoding="utf-8"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009" 
			   xmlns:s="library://ns.adobe.com/flex/spark" 
			   xmlns:mx="library://ns.adobe.com/flex/mx" minWidth="955" minHeight="600" xmlns:ns1="*">
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	<fx:Script>
		<![CDATA[
			import CamMapfilters.gradientRemove;
			
			import ImageStuff.ImageStuff;
			
			import MultiProjector.multiProjector;
			
			import com.nodename.Delaunay.Triangle;
			
			import flash.display.*;
			import flash.media.*;
			
			import mx.collections.ArrayCollection;
			import mx.graphics.codec.PNGEncoder;
			import mx.utils.ObjectUtil;
			
			import structuredlight.*;
			
			//for loading the camera
			public var cam:Camera
			//public var vid:Video
			public var bmd:BitmapData
			public var current_refresher:Timer 
			
			
			private var fileO:MapFileOpener = new MapFileOpener()
			public var camMap_stitched:CameraProjecterMap2;
			
			public var cam_resolutions:ArrayCollection = new ArrayCollection(
				[ {label:"640 x 480", width:640, height:480}, 
					{label:"320 x 240", width:320, height:240}, 
					{label:"160 x 120", width:160, height:120}
				]
			)
			
			
			public function load_camera(e:Event=null):void
			{
				cam = _camDisp.camera;
				/*
				cam = Camera.getCamera( camlist.selectedIndex.toString() )
				
				var wid:int = 320
				var hei:int = 240
				if(resolution_form){
					wid = resolution_form.selectedItem.width
					hei = resolution_form.selectedItem.height
					cam.setMode( wid, hei, 60)
					vidDisp.width = wid
					vidDisp.height = hei
				}
				vidDisp.attachCamera( cam)
				*/
			}
			
			//
			// MULTIPROJECTOR
			//
			public var mp:multiProjector 
			public function projectorsStart( numberOfProjectors,  timeout:int )
			{
				mp = new multiProjector( _camDisp.camera , stage );
				mp.graycode_divider = Math.pow( 2, _coarsness.value);
				mp._tone = _color.value * 0x010101;
				mp.callib_3( _thresh_hold.value , numberOfProjectors , timeout );
			}
			
			
			
			
			
			
			
			//
			// testing related
			//
			public function showImage( n:int = 0)
			{
				if( n >= mp.projector_count)
					return ;
				
				var sb:Sandbox3 = mp.sbList[n] ;
				
				_imgCallib.source = new Bitmap( sb.makeImage() );
				
			}
			
			
			//
			// INTERPOLATION STUFF
			//
			
			
			
			var projMap_list:Array = new Array()
			
			public function interpallHandler():void
			{
				_log.text += " interpolating __" ;
				//TODO destroy old proj maps
				projMap_list = new Array()
				interpolateAll();
			}
			public function interpolateAll():void
			{
				var n:int = projMap_list.length; 
				if( n < mp.sbList.length && n >= 0)
				{
					var sb:Sandbox3 = mp.sbList[ n ];
					var pm:ProjectorMap = new ProjectorMap( sb.graymap) ;
					pm.addEventListener( pm.DONE_EVENT_STRING, donelistener )
					pm.interpolate( _pointsKept.value );
					projMap_list[n] = pm; ;
					_log.text += "\n interpolated : " + n; 
					//setTimeout( interpolateAll, 10);
				}
				else
				{
					_log.text += "\n done interpolating";
					
				}
				
			}
			public function donelistener(e:Event)
			{
				//maybe put some cool loading cursor here
				_log.text += " .. wait .. ";
				
				// REMOVE EVENT LISTENER. 
				// this is a sweet peice of code.
				e.target.removeEventListener( e.type, arguments.callee );
				
				setTimeout( interpolateAll, 60);
			}
			/*public function interpolate1( n:int):void
			{
			if( n < mp.sbList.length && n >= 0)
			{
			var sb:Sandbox3 = mp.sbList[ n ];
			var pm:ProjectorMap = new ProjectorMap( sb.graymap) ;
			pm.interpolate( _pointsKept.value );
			projMap_list[n] = pm; ;
			_log.text += "\n interpolated : " + n; 
			}
			}
			*/
			
			
			public function stitch():Displacement24
			{
				makeChangesPermanent();
				
				var w:int = mp.sbList[0].graymap._screen_width;
				var h:int = mp.sbList[0].graymap._screen_height;
				
				var resultX:BitmapData = new BitmapData( w , h, false, 0x7fffff );
				var resultY:BitmapData = new BitmapData( w , h, false, 0x7fffff );
				
				var n_proj:int = mp.projector_count ;
				
				if( projMap_list.length > 0 )
				{
					for( var i:int = 0 ; i < projMap_list.length ; i++ )
					{
						var pm:ProjectorMap = projMap_list[ i];
						var d24:Displacement24 = new Displacement24();
						d24.fromProjectorMap( pm);
						var bmX:BitmapData = d24.mapX;
						var bmY:BitmapData = d24.mapY;
						
						var rect:Rectangle = new Rectangle( i*w /n_proj, 0, w / n_proj, h);
						
						var activeX:ByteArray = bmX.getPixels( rect);
						var activeY:ByteArray = bmY.getPixels( rect);
						activeX.position = 0;
						activeY.position = 0;
						resultX.setPixels( rect, activeX);
						resultY.setPixels( rect, activeY);
						// resultX.fillRect( rect, Math.random() * 0xffffff);
						
					}
				}
				var resultd24:Displacement24 = new Displacement24( resultX, resultY);
				
				_img.source = new Bitmap( resultX);
				
				return resultd24 ;
			}
			var d24:Displacement24
			public function stitchAndDisplay():void
			{
				d24 = stitch();
				_img2.source = new Bitmap( d24.quickBMP( stage.width, stage.height) );
				d24.init();
				
				//vidDisp.filters = [d24.filter]
				_img2.filters = [d24.filter];
			}
			
			public function imageSave( n:String):void
			{
				var f2:FileReference = new FileReference();
				
				var encoder:PNGEncoder = new PNGEncoder()
				
				if( n=="x")
				{
					var bytesX:ByteArray = encoder.encode( d24.mapX);
					
					f2.save( bytesX, "xdisplacement.png" );
				}
				else if ( n=="y")
				{
					var bytesY:ByteArray = encoder.encode( d24.mapY);
					
					f2.save( bytesY, "ydisplacement.png" );
				}
			}
			
			
			//
			//
			//
			//  make mesh for quartz
			//    a paul bourke style mesh
			//
			function mesh_num_change():void
			{
				if( _mesh_num.value < projMap_list.length)
				{
					reverseTriangles( projMap_list[ _mesh_num.value ]);
				}
			}
			function reverseTriangles( projmap:ProjectorMap ):void
			{
				
				
				if( projmap)
				{
					var bm:BitmapData = new BitmapData( projmap.width(), projmap.height() , false, 0x000000);
					var s:Shape = new Shape();
					s.graphics.lineStyle(1, 0xffffff );
					
					
					var camTriads:Vector.<Array> = projmap.getCameraTriangles();
					for each( var tr:Array in camTriads)
					{
						s.graphics.moveTo( tr[0].x ,tr[0].y);
						s.graphics.lineTo( tr[1].x, tr[1].y);
						s.graphics.lineTo( tr[2].x, tr[2].y);
						s.graphics.lineTo( tr[0].x, tr[0].y);
						
						
					}
					bm.draw( s);
					_mesh_img.source = new Bitmap( bm);
				}
				
			}
			function removeSkinnyTriangles():void
			{
				if( _mesh_num.value < projMap_list.length)
				{
					var proj_map:ProjectorMap = projMap_list[ _mesh_num.value];
					var pmf:meshFilter = new meshFilter( proj_map);
					pmf.removeBadByAngle();
					reverseTriangles( proj_map);
				}
			}
			function removeLongTriangles():void
			{
				if( _mesh_num.value < projMap_list.length)
				{
					var proj_map:ProjectorMap = projMap_list[ _mesh_num.value];
					var pmf:meshFilter = new meshFilter( proj_map);
					pmf.removeBadBySideLength();	
					reverseTriangles( proj_map);
				}
			}
			
			/*  this technique turned out to be harder than just stitching the actual projector maps together then making a mesh
			function stitchUVMeshes()
			{
			
			var meshList:Array = new Array( );
			var n_proj:int = mp.projector_count ;
			
			var wid:int = 0;
			var hei:int = 0;
			
			if( projMap_list.length > 0 )
			{
			for( var i:int = 0 ; i < projMap_list.length ; i++ )
			{
			//make bourke mesh for each projector map
			//
			var proj_map:ProjectorMap = projMap_list[ i];
			var mesh:BourkeMesh = new BourkeMesh();
			mesh.projMapToBourkeMesh( proj_map);
			wid = mesh.width;
			hei = mesh.height;
			var st:String = mesh.meshString ;
			meshList.push( st);
			}
			
			//combine all meshes into 1 mesh
			//
			
			var newWidth:int = int( meshList.length * wid );
			var newHeight:int = hei;
			var meshString:String =  "2\n" + newWidth + " " + newHeight + "\n";
			
			// seperate each map into an array of different lines
			//  so var seperated is an array of arrays
			var seperated:Array = new Array();
			for( i = 0; i < meshList.length; i++ )
			{
			var currentBourke:String = meshList[i];
			seperated.push( currentBourke.split('\n').slice(2) );//seperate, and throw out first two lines. 
			}
			
			while( seperated[0].length >= width )
			{
			for( i=0; i < seperated.length;i++)
			{
			var sep:Array = seperated[i];
			var oneleaf:Array = sep.slice(0, wid );
			for( var n1:int = 0; n1 < oneleaf.length; n1++)
			{
			//IMPORTANT : TODO CHANGE X,Y VALUES SO THAT THEY DON'T OVERLAP. 
			//   oneleaf[ n1].x = ?
			meshString += oneleaf[n1] + "\n" ;
			}
			seperated[i] = sep.slice( wid);
			}
			}
			_log.text = meshString;
			var newPBM:BourkeMesh = new BourkeMesh();
			newPBM.meshString = meshString;
			newPBM.saveQuartzMesh();
			}
			
			}
			*/
			/*
			function stitchUVMeshes2BACKUP()
			{
			var sb1:Sandbox3 = mp.sbList[0];
			
			
			var bigProjMap:ProjectorMap = new ProjectorMap( sb1.graymap );//maybe combine all three cam maps also
			bigProjMap.proj_map = new Array();
			
			for( var pn:int = 0 ; pn < projMap_list.length ; pn++ )
			{
			var current_pm1:ProjectorMap = projMap_list[ pn] ;
			current_pm1.triangulation();
			current_pm1.fillIn();
			}
			
			for( var pn:int = 0 ; pn < projMap_list.length ; pn++ )
			{
			var current_pm:ProjectorMap = projMap_list[ pn] ;
			bigProjMap.proj_map = bigProjMap.proj_map.concat( current_pm.proj_map );
			}
			_log.text += " projector maps stitched     width : " + bigProjMap.width() + "   height : " + bigProjMap.height() + "\n" ; 
			
			var PBM:BourkeMesh = new BourkeMesh();
			PBM.projMapToBourkeMesh( bigProjMap );
			PBM.saveQuartzMesh();
			}*/
			
			
			//
			//
			// MAKE CAHNGES PERAMNENT.
			//   this essentially saves the changes that were made by removing bad triangles from the tangled mesh. 
			//
			//   usage: Run this after you have cleaned up the to the mesh. 
			//
			//    note: this is kind of slow so you don't need to run it after every change but definatly before saving a mesh or a displacement image
			//
			function makeChangesPermanent()
			{
				
				//  make changes to all of the maps 
				//
				for( var pn:int = 0 ; pn < projMap_list.length ; pn++ )
				{
					var current_pm1:ProjectorMap = projMap_list[ pn] ;
					current_pm1.triangulation();
					current_pm1.fillIn();
				}
				
			}
			
			
			//
			//
			//  STITCH ALL  OF THE PROJECTOR MAPS TOGETHER INT ONE
			//			What does it do?   It takes a slice of each projector map od size 1/n. and puts them together to make one map.
			//          The resulting map should be the same dimensions as the individual projector maps. 
			//			
			//
			function stitchUVMeshes2()
			{
				var sb1:Sandbox3 = mp.sbList[0];
				var bigProjMap:ProjectorMap = new ProjectorMap( sb1.graymap );//maybe combine all three cam maps also
				bigProjMap.proj_map = new Array();
				
				var numOfProjs:int = projMap_list.length;
				
				//save previous changes to projector maps
				makeChangesPermanent();
				
				//get width
				var current_pm1:ProjectorMap = projMap_list[ 0] ;
				var scrWid:int  = current_pm1.width();
				var scrHeight:int = current_pm1.height();
				//
				// Take a slice out of every projector map and put them into one map
				for( var pn:int = 0 ; pn < projMap_list.length ; pn++ )
				{
					var current_pm:ProjectorMap = projMap_list[ pn] ;
					var section:Array = current_pm.proj_map.slice( Math.round( pn * scrWid / numOfProjs) ,  Math.round( (pn +1)*( scrWid / numOfProjs) )  );  
					bigProjMap.proj_map = bigProjMap.proj_map.concat( section );
				}
				
				_log.text += "# of projectors : " + numOfProjs +  "   individual proj map width  : " + scrWid + " \n"
				_log.text += " projector maps stitched     width : " + bigProjMap.width() + "   height : " + bigProjMap.height() + "\n" ; 
				
				if( scrWid != bigProjMap.width() )
				{
					_log.text += " ERROR in stitchmesh :   indiividual map size does not equal final stitched map size. my bad" ;
				}
				
				//
				// Output the mesh to a file
				//
				var PBM:BourkeMesh = new BourkeMesh();
				PBM.projMapToBourkeMesh( bigProjMap, scrWid / 16 , scrHeight / 16 );
				PBM.saveQuartzMesh();
				_img.source new Bitmap( PBM.displayMesh() );
			}
			
			
			public function removeBadGradient():void
			{
				
				for( var n:int = 0 ; n < mp.sbList.length; n++)
				{
					var currentSB:Sandbox3 = mp.sbList[n];
					
					var grad:gradientRemove = new gradientRemove();
					
					_log.text += " removing gradient " + n ;
					currentSB.graymap = grad.removeBadGradient( currentSB.graymap);
					_log.text += "\n" + grad._log;
				}
				
			}
			
			//
			
			
			
			//  TESTING 1,2 , ,1,2
			//
			//  FIND OVERLAPPING REGIONS
			//
			function getOverlaps()
			{
				//
				//  first stitch 3 projectors together
				//    note this is duplicated code from stitchUvMeshes2
				//
				//
				var sb1:Sandbox3 = mp.sbList[0];
				var bigProjMap:ProjectorMap = new ProjectorMap( sb1.graymap );//maybe combine all three cam maps also
				bigProjMap.proj_map = new Array();
				
				var numOfProjs:int = projMap_list.length;
				
				//save previous changes to projector maps
				makeChangesPermanent();
				
				//get width
				var current_pm1:ProjectorMap = projMap_list[ 0] ;
				var scrWid:int  = current_pm1.width();
				var scrHeight:int = current_pm1.height();
				//
				// Take a slice out of every projector map and put them into one map
				for( var pn:int = 0 ; pn < projMap_list.length ; pn++ )
				{
					var current_pm:ProjectorMap = projMap_list[ pn] ;
					var section:Array = current_pm.proj_map.slice( Math.round( pn * scrWid / numOfProjs) ,  Math.round( (pn +1)*( scrWid / numOfProjs) )  );  
					bigProjMap.proj_map = bigProjMap.proj_map.concat( section );
				}
				
				_log.text += "# of projectors : " + numOfProjs +  "   individual proj map width  : " + scrWid + " \n"
				_log.text += " projector maps stitched     width : " + bigProjMap.width() + "   height : " + bigProjMap.height() + "\n" ; 
				
				if( scrWid != bigProjMap.width() )
				{
					_log.text += " ERROR in stitchmesh :   indiividual map size does not equal final stitched map size. my bad" ;
				}
				
				
				// 
				//  get overlapping regions
				//
				//
				
				// initialise new array to hold overlaps
				//     
				var overlaps:Array = new Array( bigProjMap.width() );
				
				for( var w:int = 0 ; w < scrWid; w++)
				{
					overlaps[ w] = new Array( scrHeight );
					for( var h:int = 0 ; h < scrHeight; h++)
					{
						overlaps[w][h] = new Array;
					}
				}
				
				//   populate new Array
				//
				for( var x:int = 0 ; x < bigProjMap.width(); x++)
				{
					for( var y:int = 0 ; y < bigProjMap.height(); y++)
					{
						var pp:Point = bigProjMap.getProjXY( x,y);
						if( pp.x > 0 && pp.x < scrWid   &&   pp.y > 0 && pp.y < scrHeight)
						{
							overlaps[pp.x][ pp.y].push( new Point(x,y) );
						}
					}
				}
				
				//
				// MAKE DISPLACEMENT MAPS WITH OPACTITY
				//
				var d16:Displacement24 = new Displacement24();
				d16.fromProjectorMap( bigProjMap );
				
				
				
				
				
				
			}
			
			
			
			
			
		]]>
	</fx:Script>
	
	
	<mx:Image x="0" y="0" id="_img"/>	
	<s:TextArea x="713" y="25" width="283" id="_log" />
	<mx:Image x="0" y="0" id="_img2"/>
	<mx:TabNavigator x="30" y="10" width="676" height="564"  contentBackgroundAlpha="0.0" contentBackgroundColor="#989898">
		<s:NavigatorContent label="select camera" width="100%" height="100%" contentBackgroundAlpha="0.0" backgroundAlpha="0.0">
			<ns1:camDisplay x="10" y="0" width="654" height="521" id="_camDisp">
			</ns1:camDisplay>
		</s:NavigatorContent>
		<s:NavigatorContent label="callibration" width="100%" height="100%">
			<mx:Image x="0" y="0" id="_imgCallib"/>
			<s:Button x="10" y="164" label="CALLIBRATE" click="projectorsStart(_number_of_projectors.value, _timeout.value)"/>
			<s:NumericStepper x="13" y="22" minimum="1" maximum="10" stepSize="1" id="_number_of_projectors" value="3"/>
			<s:HSlider x="10" y="79" minimum="0" maximum="255" stepSize="1" value="14" id="_thresh_hold" />
			<s:Label x="10" y="62" text="threshold" width="59" />
			<s:HSlider x="10" y="134" id="_timeout" minimum="200" maximum="3000" stepSize="100" value="1000"/>
			<s:Label x="10" y="114" text="time to change states"/>
			<s:Label x="13" y="2" text="number of projectors"/>
			<s:Button x="66" y="235" label="show Image" click="showImage( _sbImage_num.value)"/>
			<s:NumericStepper x="10" y="235" id="_sbImage_num" minimum="0" maximum="10" stepSize="1"/>
			<s:HSlider x="155" y="73" id="_color" minimum="0" maximum="255" value="128" stepSize="1"/>
			<s:Label x="155" y="50" text="gray color"/>
			<s:HSlider x="142" y="135" minimum="0" change="_coarsness_label.text=(Math.pow( 2,  _coarsness.value) ).toString()" id="_coarsness" maximum="10" stepSize="1" value="3"/>
			<s:Label x="143" y="114" text="coarsness"/>
			<s:Label x="207" y="113" text="8" id="_coarsness_label"/>
			<s:Button x="10" y="283" label="remove bad gradient" click="removeBadGradient()" />
			<s:Label x="9" y="211" text="Post callibration stuff" textDecoration="underline" fontSize="20" fontWeight="bold"/>
			
		</s:NavigatorContent>
		<s:NavigatorContent label="interpolation" width="100%" height="100%" backgroundAlpha="0.0">
			<s:Label x="10" y="60" text="percent points to keep"/>
			<s:HSlider x="10" y="74" id="_pointsKept" minimum="0.0" maximum="1.0" stepSize="0.05" value="0.8"/>
			<s:Button x="11" y="88" label="interpolate All" click="interpallHandler()"/>
			<s:Button x="10" y="107" label="stitch and display" click="stitchAndDisplay()"/>
			<s:Label x="107" y="0" text="interpolate. then check to see if griid looks good"/>
			<s:Label x="109" y="9" text="also remember. this is still in early developement. so it won't look perfect, yet. ;D" width="455"/>
		</s:NavigatorContent>
		<s:NavigatorContent label="clean up meshes" width="100%" height="100%">
			<mx:Image x="165" y="11" id="_mesh_img"/>
			<s:NumericStepper x="10" y="0" id="_mesh_num" minimum="0" maximum="10" change="mesh_num_change()"/>
			<s:Button x="10" y="78" label="remove skinny triangles" click="removeSkinnyTriangles()"/>
			<s:Button x="10" y="107" label="remove really long triangles" click="removeLongTriangles()"/>
		</s:NavigatorContent>
		<s:NavigatorContent label="save displacement maps" width="100%" height="100%" backgroundAlpha="1.0">
			<s:Button x="10" y="57" label="save X Displacement" click="imageSave('x') " />
			<s:Button x="150" y="58" label="save Y Displacement" click="imageSave('y') "/>
			<s:Label x="10" y="19" text="Save both of these images." fontSize="17" fontWeight="bold"/>
			<s:Button x="10" y="167" label="save stitch meshes" click="stitchUVMeshes2()"/>
			<s:Label x="10" y="124" text="AND / OR" fontSize="17" fontWeight="bold" width="140"/>
		</s:NavigatorContent>
	</mx:TabNavigator>
	
</s:Application>
