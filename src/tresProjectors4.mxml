<?xml version="1.0" encoding="utf-8"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009" 
			   xmlns:s="library://ns.adobe.com/flex/spark" 
			   xmlns:mx="library://ns.adobe.com/flex/mx" minWidth="955" minHeight="600" xmlns:ns1="*">
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	<fx:Script>
		<![CDATA[
			import CamMapfilters.gradientRemove;
			
			import ImageStuff.ImageStuff;
			
			import MultiProjector.MultiImageBlend;
			import MultiProjector.MultiProjMapBlend;
			import MultiProjector.PointOpaque;
			import MultiProjector.multiProjector;
			
			import com.nodename.Delaunay.Triangle;
			
			import flash.display.*;
			import flash.media.*;
			
			import mx.collections.ArrayCollection;
			import mx.graphics.codec.PNGEncoder;
			import mx.utils.ObjectUtil;
			
			import structuredlight.*;
			
			//for loading the camera
			public var cam:Camera
			//public var vid:Video
			public var bmd:BitmapData
			public var current_refresher:Timer 
			
			
			private var fileO:MapFileOpener = new MapFileOpener()
			public var camMap_stitched:CameraProjecterMap2;
			
			public var cam_resolutions:ArrayCollection = new ArrayCollection(
				[ {label:"640 x 480", width:640, height:480}, 
					{label:"320 x 240", width:320, height:240}, 
					{label:"160 x 120", width:160, height:120}
				]
			)
			
			
			public function load_camera(e:Event=null):void
			{
				cam = _camDisp.camera;
				/*
				cam = Camera.getCamera( camlist.selectedIndex.toString() )
				
				var wid:int = 320
				var hei:int = 240
				if(resolution_form){
					wid = resolution_form.selectedItem.width
					hei = resolution_form.selectedItem.height
					cam.setMode( wid, hei, 60)
					vidDisp.width = wid
					vidDisp.height = hei
				}
				vidDisp.attachCamera( cam)
				*/
			}
			
			//
			// MULTIPROJECTOR
			//
			public var mp:multiProjector 
			public function projectorsStart( numberOfProjectors,  timeout:int )
			{
				mp = new multiProjector( _camDisp.camera , stage );
				mp.graycode_divider = Math.pow( 2, _coarsness.value);
				mp._tone = _color.value * 0x010101;
				mp.callib_3( _thresh_hold.value , numberOfProjectors , timeout );
			}
			
			
			
			
			
			
			
			//
			// testing related
			//
			public function showImage( n:int = 0)
			{
				if( n >= mp.projector_count)
					return ;
				
				var sb:Sandbox3 = mp.sbList[n] ;
				
				_imgCallib.source = new Bitmap( sb.makeImage() );
				
			}
			
			
			//
			// INTERPOLATION STUFF
			//
			
			
			
			var projMap_list:Array = new Array()
			
			public function interpallHandler():void
			{
				_log.text += " interpolating __" ;
				//TODO destroy old proj maps
				projMap_list = new Array()
				interpolateAll();
			}
			public function interpolateAll():void
			{
				var n:int = projMap_list.length; 
				if( n < mp.sbList.length && n >= 0)
				{
					var sb:Sandbox3 = mp.sbList[ n ];
					var pm:ProjectorMap = new ProjectorMap( sb.graymap) ;
					pm.addEventListener( pm.DONE_EVENT_STRING, donelistener )
					pm.interpolate( _pointsKept.value );
					projMap_list[n] = pm; ;
					_log.text += "\n interpolated : " + n; 
					//setTimeout( interpolateAll, 10);
				}
				else
				{
					_log.text += "\n done interpolating";
					
				}
				
			}
			public function donelistener(e:Event)
			{
				//maybe put some cool loading cursor here
				_log.text += " .. wait .. ";
				
				// REMOVE EVENT LISTENER. 
				// this is a sweet peice of code.
				e.target.removeEventListener( e.type, arguments.callee );
				
				setTimeout( interpolateAll, 60);
			}
			/*public function interpolate1( n:int):void
			{
			if( n < mp.sbList.length && n >= 0)
			{
			var sb:Sandbox3 = mp.sbList[ n ];
			var pm:ProjectorMap = new ProjectorMap( sb.graymap) ;
			pm.interpolate( _pointsKept.value );
			projMap_list[n] = pm; ;
			_log.text += "\n interpolated : " + n; 
			}
			}
			*/
			
			
			public function stitch():Displacement24
			{
				makeChangesPermanent();
				
				var w:int = mp.sbList[0].graymap._screen_width;
				var h:int = mp.sbList[0].graymap._screen_height;
				
				var resultX:BitmapData = new BitmapData( w , h, false, 0x7fffff );
				var resultY:BitmapData = new BitmapData( w , h, false, 0x7fffff );
				
				var n_proj:int = mp.projector_count ;
				
				if( projMap_list.length > 0 )
				{
					for( var i:int = 0 ; i < projMap_list.length ; i++ )
					{
						var pm:ProjectorMap = projMap_list[ i];
						var d24:Displacement24 = new Displacement24();
						d24.fromProjectorMap( pm);
						var bmX:BitmapData = d24.mapX;
						var bmY:BitmapData = d24.mapY;
						
						var rect:Rectangle = new Rectangle( i*w /n_proj, 0, w / n_proj, h);
						
						var activeX:ByteArray = bmX.getPixels( rect);
						var activeY:ByteArray = bmY.getPixels( rect);
						activeX.position = 0;
						activeY.position = 0;
						resultX.setPixels( rect, activeX);
						resultY.setPixels( rect, activeY);
						// resultX.fillRect( rect, Math.random() * 0xffffff);
						
					}
				}
			
				var resultd24:Displacement24 = new Displacement24( resultX, resultY);
				
				_img.source = new Bitmap( resultX);
				
				return resultd24 ;
			}
			
			
			var d24:Displacement24
			public function stitchAndDisplay():void
			{
				d24 = stitch();
				_img2.source = new Bitmap( d24.quickBMP( stage.width, stage.height) );
				d24.init();
				
				//vidDisp.filters = [d24.filter]
				_img2.filters = [d24.filter];
			}
			
			public function imageSave( n:String):void
			{
				var f2:FileReference = new FileReference();
				
				var encoder:PNGEncoder = new PNGEncoder()
				
				if( n=="x")
				{
					var bytesX:ByteArray = encoder.encode( d24.mapX);
					
					f2.save( bytesX, "xdisplacement.png" );
				}
				else if ( n=="y")
				{
					var bytesY:ByteArray = encoder.encode( d24.mapY);
					
					f2.save( bytesY, "ydisplacement.png" );
				}
			}
			
			
			//
			//
			//
			//  make mesh for quartz
			//    a paul bourke style mesh
			//
			function mesh_num_change():void
			{
				if( _mesh_num.value < projMap_list.length)
				{
					reverseTriangles( projMap_list[ _mesh_num.value ]);
				}
			}
			function reverseTriangles( projmap:ProjectorMap ):void
			{
				
				
				if( projmap)
				{
					/*var s:Shape = new Shape();
					s.graphics.lineStyle(1, 0xffffff );
					
					
					var camTriads:Vector.<Array> = projmap.getCameraTriangles();
					for each( var tr:Array in camTriads)
					{
						s.graphics.moveTo( tr[0].x ,tr[0].y);
						s.graphics.lineTo( tr[1].x, tr[1].y);
						s.graphics.lineTo( tr[2].x, tr[2].y);
						s.graphics.lineTo( tr[0].x, tr[0].y);
						
						
					}
					bm.draw( s);
					*/	
					var imgScale:Number = 1.5;
					var bm:BitmapData = projmap.drawCamTriangles( 0x00000000, 0xff0b00b5, 0xff000000, imgScale);
					_mesh_img.source = new Bitmap( bm);
				}
				
			}
			function removeSkinnyTriangles():void
			{
				if( _mesh_num.value < projMap_list.length)
				{
					var proj_map:ProjectorMap = projMap_list[ _mesh_num.value];
					var pmf:meshFilter = new meshFilter( proj_map);
					pmf.removeBadByAngle();
					reverseTriangles( proj_map);
				}
			}
			function removeLongTriangles():void
			{
				if( _mesh_num.value < projMap_list.length)
				{
					var proj_map:ProjectorMap = projMap_list[ _mesh_num.value];
					var pmf:meshFilter = new meshFilter( proj_map);
					pmf.removeBadBySideLength();	
					reverseTriangles( proj_map);
				}
			}
			

			
			
			//
			//
			// MAKE CAHNGES PERAMNENT.
			//   this essentially saves the changes that were made by removing bad triangles from the tangled mesh. 
			//
			//   usage: Run this after you have cleaned up the to the mesh. 
			//
			//    note: this is kind of slow so you don't need to run it after every change but definatly before saving a mesh or a displacement image
			//
			function makeChangesPermanent()
			{
				
				//  make changes to all of the maps 
				//
				for( var pn:int = 0 ; pn < projMap_list.length ; pn++ )
				{
					var current_pm1:ProjectorMap = projMap_list[ pn] ;
					current_pm1.triangulation();
					current_pm1.fillIn();
				}
				
			}
			
			
			//
			//
			//  STITCH ALL  OF THE PROJECTOR MAPS TOGETHER INT ONE
			//			What does it do?   It takes a slice of each projector map od size 1/n. and puts them together to make one map.
			//          The resulting map should be the same dimensions as the individual projector maps. 
			//			
			//
			function stitchUVMeshes2()
			{
				var sb1:Sandbox3 = mp.sbList[0];
				var bigProjMap:ProjectorMap = new ProjectorMap( sb1.graymap );//maybe combine all three cam maps also
				bigProjMap.proj_map = new Array();
				
				var numOfProjs:int = projMap_list.length;
				
				//save previous changes to projector maps
				makeChangesPermanent();
				
				//get width
				var current_pm1:ProjectorMap = projMap_list[ 0] ;
				var scrWid:int  = current_pm1.width();
				var scrHeight:int = current_pm1.height();
				//
				// Take a slice out of every projector map and put them into one map
				for( var pn:int = 0 ; pn < projMap_list.length ; pn++ )
				{
					var current_pm:ProjectorMap = projMap_list[ pn] ;
					var section:Array = current_pm.proj_map.slice( Math.round( pn * scrWid / numOfProjs) ,  Math.round( (pn +1)*( scrWid / numOfProjs) )  );  
					bigProjMap.proj_map = bigProjMap.proj_map.concat( section );
				}
				
				_log.text += "# of projectors : " + numOfProjs +  "   individual proj map width  : " + scrWid + " \n"
				_log.text += " projector maps stitched     width : " + bigProjMap.width() + "   height : " + bigProjMap.height() + "\n" ; 
				
				if( scrWid != bigProjMap.width() )
				{
					_log.text += " ERROR in stitchmesh :   indiividual map size does not equal final stitched map size. my bad" ;
				}
				
				//
				// Output the mesh to a file
				//
				var PBM:BourkeMesh = new BourkeMesh();
				PBM.projMapToBourkeMesh( bigProjMap, scrWid / 16 , scrHeight / 16 );
				PBM.saveQuartzMesh();
				_img.source new Bitmap( PBM.displayMesh() );
			}
			
			
			public function removeBadGradient():void
			{
				
				for( var n:int = 0 ; n < mp.sbList.length; n++)
				{
					var currentSB:Sandbox3 = mp.sbList[n];
					
					var grad:gradientRemove = new gradientRemove();
					
					_log.text += " removing gradient " + n ;
					currentSB.graymap = grad.removeBadGradient( currentSB.graymap);
					_log.text += "\n" + grad._log;
				}
				
			}
			
			//
			
			/*
			
			//  TESTING 1,2 , ,1,2
			//
			//  FIND OVERLAPPING REGIONS
			//
			function testOpacity()
			{
				var meshString:String =  getOpacities();
				_log.text += blendOpacs._log;
				var fr:FileReference
				fr = new FileReference();
				//var str:String = MakeUVMap4Quartz(xdivisions, ydivisions );
				fr.save( meshString, "QuartzPBMesh.data");
			}
			//var opacityMap:Array = [];	
			var blendOpacs:MultiImageBlend = new MultiImageBlend();

			public function getOpacities()
			{
				makeChangesPermanent();	
				//
				//
				// initialise opacities
				var blendImages:Array = [];
				
				
				for each( var prm:ProjectorMap in projMap_list)
				{
					var tmpbmp:Bitmap = new Bitmap( prm.drawCamTriangles( 0xff << 24 | (0xff0000 | 0x88 * projMap_list.length) , 0xff0000ff,0x00000000,1.0));
					blendImages.push( tmpbmp );
				}
				blendOpacs = new MultiImageBlend();
				blendOpacs.blendBitmaps( blendImages );
				
				_log.text += blendOpacs._log;
					
				var bm1:BitmapData = blendOpacs.getImage();
				var bmBigger:BitmapData = new BitmapData( bm1.width , bm1.height );
				bmBigger.draw( bm1, new Matrix( 1,0,0,1));
				
				_mesh_img.source = new Bitmap( bmBigger  );
				
				setTimeout( stitchUVMeshesWithOpacity, 50);
			}
			public function stitchUVMeshesWithOpacity():String
			{	

				var sb1:Sandbox3 = mp.sbList[0];
				var numOfProjs:int = projMap_list.length;
				
	
			//get width
				var current_pm1:ProjectorMap = projMap_list[ 0] ;
				var scrWid:int  = current_pm1.width();
				var scrHeight:int = current_pm1.height();
				
				
				_log.text += "\n # of projectors : " + numOfProjs +  "   individual proj map width  : " + scrWid + " \n"
				

				//
				//
				//  Make string
				//
				var xdivisions:int = 96;
				var ydivisions:int = 54;
				
				var result:String = "2 \n";
				// todo figure out resolution automatically

				
				
				//
				//  put all nodes into an array 
				//
				result += int(xdivisions + 1) + " " + int(ydivisions + 1) + "\n";
				var nodes:Array = new Array( ydivisions +1);
				for( var yn:Number = 0 ; yn <= ydivisions; yn++)
				{
					nodes[ yn] = new Array( xdivisions + 1);
				}
				
				 // number of x divisions per projector
				var xdPerProjector:Number = xdivisions / projMap_list.length ;
				
				for( var yn:Number = 0 ; yn <= ydivisions; yn++)
				{
					for( var xn:Number = 0; xn <= xdivisions ; xn ++  ) 
					{
						var x:Number = 2 * ( xn / xdivisions ) - 1 ;
						var y:Number = 2 * ( yn / ydivisions ) - 1;
						var currProjectorIndex:int = Math.floor( xn * projMap_list.length / xdivisions);
						if(currProjectorIndex >= projMap_list.length)
							currProjectorIndex = projMap_list.length - 1 ;
						var currProjector:ProjectorMap = projMap_list[ currProjectorIndex ];
						// x and y positions in screen dimensions
						var xm:int  = Math.floor( (xn/xdivisions) * scrWid ) ;
						var ym:int = Math.floor( (yn/ydivisions) * scrHeight) ;
						
						if( ! currProjector)
							_log.text += "  curr projector  null " + currProjectorIndex;
						var u:Number = currProjector.getProjXY(xm,ym).x;
						var v:Number = currProjector.getProjXY(xm,ym).y;
						var i:Number = -1;
						if( u >=0 && v >=0 )
						{
							i = blendOpacs.getOpacities(u,v)[ currProjectorIndex ];	
							u =  u / scrWid ;// ??? todo: should this be u = u / camera_width;???
							v =  v / scrHeight ;/// ??? This too ???
						}
						else
						{
							u = v = -1000;
							i = -1 ;
						}
						//push an object on
						nodes[yn][xn] = { x:x , y:y , u:u , v:v ,i:Number(i)}; 
					}
				}
				
				//
				// convert nodes[][] to a properly formatted string
				//
				for( var yn:Number = 0 ; yn <= ydivisions; yn++)
				{
					for( var xn:Number = 0; xn <= xdivisions ; xn ++  ) 
					{
						var tmpObj:Object = nodes[yn][xn];
						//
						//
						//  handle the border issues 
						//       make all borders translucent
						//       
						//    		
						var i2:Number = Number(tmpObj.i);
						
						if( xn == 0 || yn == 0)
							i2 = -1;
						else if( xn == xdivisions || yn == ydivisions)
							i2 = -1;
						else if( nodes[yn][xn-1].i < 0 )
							i2 = -1;
						else if( nodes[yn][xn+1].i < 0 )
							i2 = -1;
						else if( nodes[yn-1][xn].i < 0 )
							i2 = -1;
						else if( nodes[yn+1][xn].i < 0 )
							i2 = -1;
						
						
						//
						//  finally outputto the final string
						//
						result += tmpObj.x + " " + -1 * tmpObj.y + " " + ( tmpObj.u ).toString() + " " + (1- tmpObj.v ).toString() + " " + i2 + "\n";					
					}
				}
				return result;
			}
			
			*/
			function meshWOpacity2()
			{
				var mpb:MultiProjMapBlend = new MultiProjMapBlend( projMap_list );
				_mesh_img.source = new Bitmap( mpb.getImage() );
			}
			/*
			function meshImgClick( e:MouseEvent):void
			{
				var x:Number = e.localX;
				var y:Number = e.localY;
				
				if( blendOpacs && blendOpacs.ready )
				{
					_log.text += " { "+ x + " , " + y + " : " + blendOpacs.getOpacities(x,y) + " dist : " + blendOpacs.getDistances(x,y) + "} , " ; 
				}
				else
				{
					_log.text += "blend opacs not ready";
				}
			}
			*/
			public function goFullScreen( )
			{
				stage.addEventListener(FullScreenEvent.FULL_SCREEN, goBIGhandler)
				stage.displayState = "fullScreen"	
			}
			public function goBIGhandler( e:FullScreenEvent)
			{
				
			}
			
			//
			//this should help with some image scaling issues
			//
			/*
			public function findDisplayRect():Rectangle
			{
				if( blendOpacs && blendOpacs.ready)
				{
					var bm:BitmapData = blendOpacs.getImage() ;
					var rect:Rectangle = bm.getColorBoundsRect( 0x00ffffff, 0x00000000, false);
					var sh:Shape = new Shape();
					sh.graphics.beginFill(0xffffff00,0.7);
					sh.graphics.lineStyle( 3, 0xffff0000, 1.0);
					sh.graphics.drawRect( rect.x, rect.y, rect.width, rect.height);
					sh.graphics.endFill();
					bm.draw(sh);
					_mesh_img.source = new Bitmap( bm);
					_log.text += " active rect : " + rect.toString(); 
					return rect;
				}
				else{
					return null;
				}
			}
			*/
			
			
		]]>
	</fx:Script>
	
	
	<mx:Image x="0" y="0" id="_img"/>	
	<s:TextArea x="713" y="25" width="283" id="_log" />
	<mx:Image x="0" y="0" id="_img2"/>
	<mx:TabNavigator x="30" y="10" width="676" height="564"  contentBackgroundAlpha="0.0" contentBackgroundColor="#989898">
		<s:NavigatorContent label="select camera" width="100%" height="100%" contentBackgroundAlpha="0.0" backgroundAlpha="0.0">
			<ns1:camDisplay x="10" y="0" width="654" height="521" id="_camDisp">
			</ns1:camDisplay>
			<s:Button x="428" y="414" label="FULL screen" fontSize="21" click="goFullScreen()"/>
		</s:NavigatorContent>
		<s:NavigatorContent label="callibration" width="100%" height="100%">
			<mx:Image x="0" y="0" id="_imgCallib"/>
			<s:Button x="10" y="164" label="CALLIBRATE" click="projectorsStart(_number_of_projectors.value, _timeout.value)"/>
			<s:NumericStepper x="13" y="22" minimum="1" maximum="10" stepSize="1" id="_number_of_projectors" value="3"/>
			<s:HSlider x="10" y="79" minimum="0" maximum="255" stepSize="1" value="14" id="_thresh_hold" />
			<s:Label x="10" y="62" text="threshold" width="59" />
			<s:HSlider x="10" y="134" id="_timeout" minimum="200" maximum="3000" stepSize="100" value="1000"/>
			<s:Label x="10" y="114" text="time to change states"/>
			<s:Label x="13" y="2" text="number of projectors"/>
			<s:Button x="66" y="235" label="show Image" click="showImage( _sbImage_num.value)"/>
			<s:NumericStepper x="10" y="235" id="_sbImage_num" minimum="0" maximum="10" stepSize="1"/>
			<s:HSlider x="155" y="73" id="_color" minimum="0" maximum="255" value="128" stepSize="1"/>
			<s:Label x="155" y="50" text="gray color"/>
			<s:HSlider x="142" y="135" minimum="0" change="_coarsness_label.text=(Math.pow( 2,  _coarsness.value) ).toString()" id="_coarsness" maximum="10" stepSize="1" value="3"/>
			<s:Label x="143" y="114" text="coarsness"/>
			<s:Label x="207" y="113" text="8" id="_coarsness_label"/>
			<s:Button x="10" y="283" label="remove bad gradient" click="removeBadGradient()" />
			<s:Label x="9" y="211" text="Post callibration stuff" textDecoration="underline" fontSize="20" fontWeight="bold"/>
			
		</s:NavigatorContent>
		<s:NavigatorContent label="interpolation" width="100%" height="100%" backgroundAlpha="0.0">
			<s:Label x="10" y="60" text="percent points to keep"/>
			<s:HSlider x="10" y="74" id="_pointsKept" minimum="0.0" maximum="1.0" stepSize="0.05" value="0.8"/>
			<s:Button x="11" y="88" label="interpolate All" click="interpallHandler()"/>
			<s:Button x="10" y="107" label="stitch and display" click="stitchAndDisplay()"/>
			<s:Label x="107" y="0" text="interpolate. then check to see if griid looks good"/>
			<s:Label x="109" y="9" text="also remember. this is still in early developement. so it won't look perfect, yet. ;D" width="455"/>
		</s:NavigatorContent>
		<s:NavigatorContent label="clean up meshes" width="100%" height="100%">
			<mx:Image x="165" y="11" id="_mesh_img" />
			<s:NumericStepper x="10" y="0" id="_mesh_num" minimum="0" maximum="10" change="mesh_num_change()"/>
			<s:Button x="10" y="78" label="remove skinny triangles" click="removeSkinnyTriangles()"/>
			<s:Button x="10" y="107" label="remove really long triangles" click="removeLongTriangles()"/>
			<s:Button x="10" y="145" label="meshWOpacity2()" click="meshWOpacity2()"/>
			
		</s:NavigatorContent>
		<s:NavigatorContent label="save displacement maps" width="100%" height="100%" backgroundAlpha="1.0">
			<s:Button x="10" y="57" label="save X Displacement" click="imageSave('x') " />
			<s:Button x="150" y="58" label="save Y Displacement" click="imageSave('y') "/>
			<s:Label x="10" y="19" text="Save both of these images." fontSize="17" fontWeight="bold"/>
			<s:Button x="10" y="167" label="save stitch meshes" click="stitchUVMeshes2()"/>
			<s:Label x="10" y="124" text="AND / OR" fontSize="17" fontWeight="bold" width="140"/>
			<s:Button x="10" y="203" label="save w/ opacity, TEST" click="meshWOpacity2();"/>
		</s:NavigatorContent>
	</mx:TabNavigator>
	
</s:Application>
