<?xml version="1.0" encoding="utf-8"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009" 
			   xmlns:s="library://ns.adobe.com/flex/spark" 
			   xmlns:mx="library://ns.adobe.com/flex/mx" minWidth="955" minHeight="600" viewSourceURL="srcview/index.html">
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	<fx:Script>
		<![CDATA[
			import structuredlight.BourkeMesh;
			
			var verbose:Boolean = false;
			
			var fileRef:FileReference;
			
			var pbm:BourkeMesh;
			public function importMesh()
			{
				pbm = new BourkeMesh();
				pbm.addEventListener( pbm._completeLoadingEvent, importComplete);
				pbm.importMeshFile();
			}
			
			var uvTimer:Number = 0
			public function importComplete( e:Event)
			{
				
				_img.source = new Bitmap( e.target.displayMesh() );
				_log.text = " map loaded    width" + e.target.width + "  height " + e.target.height; 
				
				drawTriangles();
			}
			
			//
			//
			///      testing uv mesh triangles
			///
			/////
			/////////
			/////////
			/////
			///
			///
			//
			//
			[Embed(source="images/radialgrid.jpg")]
			private var radialgrid:Class;
			

			
			var bmIn:Bitmap
			var xyVertices:Vector.<Number> = new Vector.<Number>;
			var uvVertices:Vector.<Number> = new Vector.<Number>;
			var indices:Vector.<int> = new Vector.<int>;
			
			var xyVerticesOriginal:Vector.<Number> = new Vector.<Number>;
			var uvVerticesOriginal:Vector.<Number> = new Vector.<Number>;
			
			private function splitAtWhiteSpace( s:String):Array
			{
				return s.replace(/^\s+/,"").replace(/\s+$/,"").split(/\s+/);//split at white spaces
			}
			
			
			
			function drawTriangles()
			{	
				uvTimer = getTimer();
				
				var bmd:BitmapData = new BitmapData( stage.width, stage.height,false,0xd00d00);
				bmIn = new radialgrid as Bitmap;
				
				
				//
				//
				////
				////  parse the String into usable numbers
				//  
				//
				if( !pbm)
				{
					_log.text += "\n load mesh file first ";
					return;
				}
				var meshRa:Array = new Array( pbm.width );
				for( var x1:int = 0; x1 < pbm.width; x1++)
				{
					meshRa[x1] = new Array( pbm.height);
				}
				
				var indexs:Array = pbm.meshString.split( "\n");
				var type:int = int(indexs[0]);
				var mesh:Array = indexs.slice(2);//TAKE EVERYTHING AFTER THE FIRST TWO LINES
				var dimensionsString:String = indexs[1]; //PARSE DIMENSIONS FROM SECOND LINE
				var dimensions:Array = splitAtWhiteSpace( dimensionsString); 
				width = int( dimensions[0]) ;
				height = int(dimensions[1]) ;
				
				var sh1:Shape = new Shape();
				_log.text = " indexs length:"+ indexs.length + " \n" ;//+ "  " +meshArray.toString();
				_log.text += " mesh array length : " + mesh.length + "\n";
				_log.text += " Loaded mesh :  width" + width + "  height "+ height + " \n"; 
				_log.text += " stage width : " + stage.width + " height " + stage.height + "\n";
				
				//
				//  Do the uv mapping with the triangles
				//
				//
				var index:int = 0 ;
				indices = new Vector.<int>;
				xyVertices = new Vector.<Number>;
				uvVertices = new Vector.<Number>;
				
				xyVerticesOriginal = new Vector.<Number>;
				uvVerticesOriginal = new Vector.<Number>;
				
				for ( var n:int = 0 ; n < mesh.length; n++)
				{
					var tmp:String = mesh[n];
					var m:Array = splitAtWhiteSpace(tmp);//split at white spaces
					
					if( m.length != 5){
						// THIS LINE DOES NOT LOOK RIGHT
						// SKIP IT. it's usually like an extra carrier return at the endof the page. 
						_log.text += "ERROR m.lengt != 5 " + m + "   at  " + n;
					}
					else
					{
						//
						// get corrected x,y
						var xc:int = n % width;
						var yc:int = Math.floor( n/width);
						
						var cent:Array =  splitAtWhiteSpace( mesh[n]);
						
						if(verbose)
							_log.text += " ( " + xc +" ,  " + yc+")";
						

						var x2:Number = (Number(cent[0]) + 1 ) * stage.width / 2;
						var y2:Number = (Number(cent[1]) + 1 ) * stage.height / 2;
						var u2:Number = Number(cent[2])  ;
						var v2:Number = Number(cent[3])   ;
						
						if( _invertBox.selected ){
							y2 = ( - Number(cent[1]) + 1 ) * stage.height / 2;	
							v2 = 1 - Number(cent[3]) ;
						}
						
						var vert:Object = {  x: x2, y: y2, u: u2 , v : v2 , i: cent[4] , index: int(index) };
						
						if(verbose)
							_log.text += "\n x: " + vert.x + " y:"+ vert.y + " u:"+ vert.u +" v:"+ vert.v +" i:"+ vert.i +   " indx:"+ vert.index ; 
						meshRa[xc][yc] = vert ;
						
						xyVertices.push( vert.x);
						xyVertices.push( vert.y);
						uvVertices.push( vert.u);
						uvVertices.push( vert.v);
						
						xyVerticesOriginal.push( Number(vert.x) );
						xyVerticesOriginal.push( Number(vert.y) );
						uvVerticesOriginal.push( Number(vert.u) );
						uvVerticesOriginal.push( Number(vert.v) );

						
						index++;
					}			
				}
				
				var outShape:Shape = new Shape();
				var uvShape:Shape = new Shape();
				uvShape.graphics.lineStyle(1,0x00f00f, 0.8);
				var xyShape:Shape = new Shape();
				xyShape.graphics.lineStyle(1,0xf0000f, 0.8);
				
				for( var x:int = 0; x < meshRa.length - 1 ; x++)
				{
					for( var y:int = 0 ; y < meshRa[0].length - 1; y++)
					{
						var center:Object = meshRa[ x ][ y ];
						var right:Object = meshRa[x + 1][ y ];
						var down:Object = meshRa[ x ][ y + 1 ];
						var diag:Object = meshRa[x + 1][ y + 1];
						if( center.i > 0 && right.i > 0 && down.i > 0 && diag.i > 0)
						{
							//push triangles
							//  first: top triange
							indices.push( center.index );
							indices.push( right.index );
							indices.push( diag.index );
							//
							//  second: bottom triangle 
							indices.push( center.index );
							indices.push( down.index );
							indices.push( diag.index );
							
							xyShape.graphics.moveTo( center.x, center.y);
							xyShape.graphics.lineTo( right.x, right.y);
							xyShape.graphics.moveTo( center.x, center.y);
							xyShape.graphics.lineTo( down.x, down.y);
							xyShape.graphics.moveTo( center.x, center.y);
							xyShape.graphics.lineTo( diag.x, diag.y);
							
							uvShape.graphics.moveTo( bmd.width * center.u, bmd.height * center.v);
							uvShape.graphics.lineTo( bmd.width * right.u, bmd.height * right.v);
							uvShape.graphics.moveTo( bmd.width * center.u, bmd.height * center.v);
							uvShape.graphics.lineTo( bmd.width * down.u, bmd.height * down.v);
							uvShape.graphics.moveTo( bmd.width * center.u, bmd.height * center.v);
							uvShape.graphics.lineTo( bmd.width * diag.u, bmd.height * diag.v);
							
						}
					}
				}
				
				outShape.graphics.beginBitmapFill( bmIn.bitmapData);
				outShape.graphics.drawTriangles( xyVertices, indices, uvVertices);
				outShape.graphics.endFill();
				
				bmd.draw( outShape );
				bmd.draw( uvShape );
				bmd.draw( xyShape );
				
				_img.source = ( new Bitmap( bmd) );
				
				//
				// count time elapsed
				_log.text += "\n uv time elapsed : " +  (getTimer() - uvTimer);  
				
			}//...drawTriangles
			
			var zoom:Number = 1;
			var bmRotation:Number = 0;
			function mouseHandler( e:MouseEvent)
			{
				
				
				zoom = zoom + 0.005 * e.delta;
				bmRotation = Math.atan2((e.stageY - stage.height/2) , (e.stageX - stage.width/2)) ;
				//zoomTest( zoom);
				rotateTest( bmRotation, zoom);

				
				var bmd2:BitmapData = new BitmapData( stage.width, stage.height);
				bmd2.draw( bmIn);
				
				redrawImage( bmd2 );
				//_log.text += " \n zoom : " + zoom + " rotation : " + bmRotation;
			}
			function rotateTest( rotation, zooms)
			{
				var mtrx:Matrix = new Matrix();	
				mtrx.rotate( rotation);
				mtrx.transformPoint( new Point(0.5, 0.5) );

				matrixTransformOfOriginal( mtrx);
				// shift left
				//matrixTransformOfOriginal( new Matrix( 1,0,0,1,-0.5, -0.5));
				//matrixTransform( new Matrix( Math.cos( rotation), Math.sin(rotation), -Math.sin(rotation), Math.cos(rotation)));
				//matrixTransform( new Matrix( 1,0,0,1,0.5, 0.5));
				//matrixTransformOfOriginal( new Matrix( Math.cos(rotation) * zooms, Math.sin(rotation) * zooms, -1 * Math.sin(rotation) * zooms , Math.cos(rotation) * zooms, 0 , 0));	
			}
			function zoomTest( scale:Number = 1)
			{
				//uvVertices = new Vector.<Number>;
				
				/*for each( var num:Number in uvVerticesOriginal)
				{
					uvVertices.push( num * scale );
				}
				*/
				matrixTransformOfOriginal( new Matrix( zoom, 0 , 0 , zoom, 0 , 0));
			}
			function matrixTransform( matrix:Matrix )
			{	
				var ycoord:Number ;
				var xcoord:Number ;
				for( var n:int = 0 ; n < uvVertices.length; n = n + 2 )
				{	
					xcoord = Number(uvVertices[n]);	
					ycoord = Number(uvVertices[ n+1]);
					
					uvVertices[n] = matrix.a * xcoord + matrix.c * ycoord + matrix.tx;//x
					uvVertices[n+1] = matrix.b * xcoord + matrix.d * ycoord + matrix.ty;//y
				}
			}
			function matrixTransformOfOriginal( matrix:Matrix )
			{	
				var ycoord:Number ;
				var xcoord:Number ;
				for( var n:int = 0 ; n < uvVerticesOriginal.length; n = n + 2 )
				{	
					xcoord = uvVerticesOriginal[n];	
					ycoord = uvVerticesOriginal[ n+1];
				
					uvVertices[n] = matrix.a * xcoord + matrix.c * ycoord + matrix.tx;//x
					uvVertices[n+1] = matrix.b * xcoord + matrix.d * ycoord + matrix.ty;//y
				}
			}
			var bmBig:BitmapData
			function redrawImage( bm2:BitmapData )
			{
				if( ! bmBig )	
					bmBig = new BitmapData( stage.width, stage.height);
				else if( bmBig.width != stage.width || bmBig.height != stage.height )
					bmBig = new BitmapData( stage.width, stage.height);
				
				var outShape:Shape = new Shape();
				outShape.graphics.beginBitmapFill( bm2);
				outShape.graphics.drawTriangles( xyVertices, indices, uvVertices);
				outShape.graphics.endFill();
				
				bmBig.draw( outShape );
				_img.source = ( new Bitmap( bmBig) );
			}
			
			public function goFullScreen( )
			{
				stage.addEventListener(FullScreenEvent.FULL_SCREEN, goBIGhandler)
				stage.displayState = "fullScreen"	;
				_log.text += " \n going Full Screen ";
			}
			public function goBIGhandler( e:FullScreenEvent)
			{
				
			}
		
		]]>
	</fx:Script>
	
	<mx:Image x="0" y="0" id="_img" mouseWheel="mouseHandler(event)" mouseMove="mouseHandler(event)"/>
	<s:Button x="69" y="67" label="load mesh .data" click="importMesh()"/>
	<s:TextArea x="445" y="115" width="482" height="450" id="_log" contentBackgroundAlpha="0.5" color="#FFFFFF" contentBackgroundColor="#000000"/>
	<s:Button x="68" y="183" label="re-draw Triangles" click="drawTriangles()"/>
	<s:Button x="69" y="106" label="FULL screen" click="goFullScreen()"/>
	<s:CheckBox x="199" y="186" label="invert" id="_invertBox" width="55" selected="true"/>
	
</s:Application>

