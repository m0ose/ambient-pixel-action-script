<?xml version="1.0" encoding="utf-8"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009" 
			   xmlns:s="library://ns.adobe.com/flex/spark" 
			   xmlns:mx="library://ns.adobe.com/flex/mx" minWidth="955" minHeight="600">
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	<fx:Script>
		<![CDATA[
			import structuredlight.BourkeMesh;
			
			
				
			var fileRef:FileReference;
			
			
			public function importMesh()
			{
				var pbm:BourkeMesh = new BourkeMesh();
				pbm.addEventListener( pbm._completeLoadingEvent, importComplete);
				pbm.importMeshFile();
			}
			
			public function importComplete( e:Event)
			{
				_img.source = new Bitmap( e.target.displayMesh() );
				_log.text = " map loaded    width" + e.target.width + "  height " + e.target.height; 
			}
			//
			//
			// stitching testing
			//
			//
			var meshList:Array = new Array();

			public function importMesh2()//second file
			{
				var pbm:BourkeMesh = new BourkeMesh();
				pbm.addEventListener( pbm._completeLoadingEvent, importComplete2);
				pbm.importMeshFile();
				
			}
			public function importComplete2( e:Event)
			{
				_img.source = new Bitmap( e.target.displayMesh() );
				_log.text = " map loaded    width" + e.target.width + "  height " + e.target.height + "\n"; 
				meshList.push( e.target);
			}
			public function stitchUVMeshes():void
			{
			
				if( meshList.length == 0 )
				{
					_log.text += " mesh list < 1   ";
					return;
				}
				var wid:int = 0;
				var hei:int = 0;
				
				wid = meshList[0].width;
				hei = meshList[0].height;
										
					//combine all meshes into 1 mesh
					//
				_log.text += " Mesh list length " + meshList.length + " \n" ; 	
				var newWidth:int = int( meshList.length * wid );
				var newHeight:int = hei;
				var meshString:String =  "2\n" + newWidth + " " + newHeight + "\n";
					
					// seperate each map into an array of different lines
					//  so var seperated is an array of arrays
				var seperated:Array = new Array();
				for( var i:int = 0; i < meshList.length; i++ )
				{
					_log.text += "mesh converted to string" + meshList[i].width + " " + meshList[i].height + "\n" ;
					var currentBourke:String = meshList[i].meshString;
					seperated.push( currentBourke.split('\n').slice(2) );//seperate, and throw out first two lines. 
				}
				
				
				for( var n:int = 0; n < newHeight; n++ )
				{
					for( var s:int =0 ; s < meshList.length; s++ )
					{
						var m:Array = seperated[s];
						var ms:Array = m.slice( n * wid, (n+1) * wid);
						for ( var n2:int = 0; n2 < ms.length ; n2++)
						{
							//NEED TODO adjust the coordinates so that they are not right on top of eachother.
							meshString += ms[ n2] + "\n";
						}
					}
				}
				
				
				//_log.text += meshString;
				_log.text += " mesh string length " + meshString.length ; 
				var newPBM:BourkeMesh = new BourkeMesh();
				newPBM.meshString = meshString;
				newPBM.saveQuartzMesh();
			}
				
			
		]]>
	</fx:Script>
	
	
	<s:Button x="69" y="67" label="load mesh .data" click="importMesh()"/>
	<s:TextArea x="69" y="110" width="482" height="450" id="_log"/>
	<mx:Image x="582" y="110" id="_img"/>
	<s:Button x="357" y="67" label="load mesh 2" click="importMesh2()"/>
	<s:Button x="481" y="67" label="stitch" click="stitchUVMeshes()"/>
	<s:Label x="267" y="67" text="stitching stuff"/>
</s:Application>