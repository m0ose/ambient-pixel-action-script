<?xml version="1.0" encoding="utf-8"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009" 
			   xmlns:s="library://ns.adobe.com/flex/spark" 
			   xmlns:mx="library://ns.adobe.com/flex/mx" minWidth="955" minHeight="600">
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	<fx:Script>
		<![CDATA[
			import structuredlight.BourkeMesh;
			
			
			
			public function displayMesh(meshString:String):BitmapData
			{
				
				
				var indexs:Array = meshString.split( "\n");
				//_log.text = " indexs length:"+ indexs.length + " \n" ;//+ "  " +meshArray.toString();
				var type:int = int(indexs[0]);
				
				
				var mesh:Array = indexs.slice(2);
				_log.text += " mesh array length : " + mesh.length + "\n";
				
				var dimensionsString:String = indexs[1]; 
				var dimensions:Array = dimensionsString.split(" ");
				var width:int = int( dimensions[0]) ;
				var height:int = int(dimensions[1]) ;
				_log.text += " Loaded mesh :  width" + width + "  height "+ height + " \n"; 
				
				
				
				var bmd:BitmapData = new BitmapData( 640,480,false,0x000000);
				var sh1:Shape = new Shape();
								
				
				for ( var n:int = 0 ; n < mesh.length; n++)
				{
					var tmp:String = mesh[n];
					var m:Array = splitAtWhiteSpace(tmp);//split at white spaces
					
					if( m.length != 5){
							_log.text += "ERROR m.lengt != 5 " + m + "   at  " + n;
					}
					else
					{
						// get corrected x,y
						var xc:int = n % width;
						var yc:int = Math.floor( n/width);
						
						var drawPoint:Boolean = true;
						if( yc <= 0){//up //could put a select case in here instead, get rid of repeated code. 
							//_log.text += "^";
							drawPoint = false;
						}
						if( yc == height - 1)//down
						{
							//_log.text += "_";
							drawPoint = false;
						}
						if( xc <= 0) //left
						{
							//_log.text += "<";
							drawPoint = false;
						}
						if( xc == width - 1)//right
						{		
							//_log.text += ">";
							drawPoint = false;
						}
						
						if( drawPoint )
						{
							var up:Array = splitAtWhiteSpace( mesh[n - width]);
							var down:Array = splitAtWhiteSpace( mesh[n + width]);
							var left:Array = splitAtWhiteSpace( mesh[n - 1]);
							var right:Array = splitAtWhiteSpace( mesh[n - 1]);
							//
							// draw xy map
							//
							sh1.graphics.lineStyle(1,0x00ff00);
							//up
							sh1.graphics.moveTo( bmd.width * (Number( m[0] ) + 1)/2 , bmd.height * (Number( m[1] ) + 1)/2); 
							sh1.graphics.lineTo( bmd.width * (Number( up[0] ) + 1)/2 , bmd.height * (Number( up[1] ) + 1)/2);
							//down
							sh1.graphics.moveTo( bmd.width * (Number( m[0] ) + 1)/2 , bmd.height * (Number( m[1] ) + 1)/2); 
							sh1.graphics.lineTo( bmd.width * (Number( down[0] ) + 1)/2 , bmd.height * (Number( down[1] ) + 1)/2);
							//left
							sh1.graphics.moveTo( bmd.width * (Number( m[0] ) + 1)/2 , bmd.height * (Number( m[1] ) + 1)/2); 
							sh1.graphics.lineTo( bmd.width * (Number( left[0] ) + 1)/2 , bmd.height * (Number( left[1] ) + 1)/2);
							//right
							sh1.graphics.moveTo( bmd.width * (Number( m[0] ) + 1)/2 , bmd.height * (Number( m[1] ) + 1)/2); 
							sh1.graphics.lineTo( bmd.width * (Number( right[0] ) + 1)/2 , bmd.height * (Number( right[1] ) + 1)/2);
						
							//
							//draw u,v map
							//
							if( Number(m[2]) >= 0 && Number(m[3]) >= 0 && Number(m[4]) >= 0)
							{
								//up
								sh1.graphics.lineStyle(2,0x0fffff);
								if( Number(up[2]) >= 0   &&   Number(up[3]) >= 0 )
								{
									sh1.graphics.moveTo( Number( m[2] ) * bmd.width , Number( m[3] ) * bmd.height ); 
									sh1.graphics.lineTo( Number( up[2]) * bmd.width , Number( up[3]) * bmd.height );
								}
								//down
								if( Number(down[2]) >= 0   &&   Number(down[3]) >= 0 )
								{
									sh1.graphics.moveTo( Number( m[2] ) * bmd.width , Number( m[3] ) * bmd.height ); 
									sh1.graphics.lineTo( Number( down[2]) * bmd.width , Number( down[3]) * bmd.height );
								}
								if( Number(left[2]) >= 0   &&   Number(left[3]) >= 0 )
								{	//left
									sh1.graphics.moveTo( Number( m[2] ) * bmd.width , Number( m[3] ) * bmd.height ); 
									sh1.graphics.lineTo( Number( left[2]) * bmd.width  , Number( left[3]) * bmd.height );
								}
								if( Number(right[2]) >= 0   &&   Number(right[3]) >= 0 )
								{	//right
									sh1.graphics.moveTo( Number( m[2] ) * bmd.width , Number( m[3] ) * bmd.height ); 
									sh1.graphics.lineTo( Number( right[2]) * bmd.width , Number( right[3]) * bmd.height );
								}

								//
								//
								//connect uv and xy
								// this looks cool, but doesn't really serve a purpose, and really clutters the screen.
								/*
								sh1.graphics.lineStyle( 1, 0xff0000 );
								sh1.graphics.moveTo( bmd.width * (Number( m[0] ) + 1)/2 , bmd.height * (Number( m[1] ) + 1)/2); 
								sh1.graphics.lineTo( Number(m[2]) * bmd.width , Number(m[3]) * bmd.height );
								*/
								
							}
								
						}
					}	
				}
				
					
		
				//sh1.graphics.endFill();
				bmd.draw(sh1);
				_img.source = new Bitmap( bmd);
		

				return bmd;
			}
			private function splitAtWhiteSpace( s:String):Array
			{
				return s.replace(/^\s+/,"").replace(/\s+$/,"").split(/\s+/);//split at white spaces
			}
				
			var fileRef:FileReference;
			
			public function importMesh()
			{
				var pbm:BourkeMesh = new BourkeMesh();
				pbm.addEventListener( pbm._completeLoadingEvent, importComplete);
				pbm.importMeshFile();
				//_img.source = new Bitmap( pbm.displayMesh() );
				//_log.text = " map loaded    width" + pbm.width + "  height " + height; 
			}
			public function importComplete( e:Event)
			{
				_img.source = new Bitmap( e.target.displayMesh() );
				_log.text = " map loaded    width" + e.target.width + "  height " + e.target.height; 
			}
			
			/*
			public function importMesh():void
			{
				fileRef= new FileReference()
				fileRef.browse( )
				fileRef.addEventListener(Event.SELECT, selectHandler)
				fileRef.addEventListener(Event.COMPLETE, completeHandler)
			}
			
			private function selectHandler(e:Event):void
			{
				fileRef.load()
			}
			private function completeHandler(e:Event):void
			{
				var meshString:String;
				meshString = fileRef.data.toString() ;
				
				var pbm:BourkeMesh = new BourkeMesh();
				pbm.meshString = meshString;
				pbm.getDimensions();
				_log.text = " map loaded    width" + pbm.width + "  height " + pbm.height; 

				_img.source = new Bitmap( pbm.displayMesh() );
				_log.text += " map loaded    width" + pbm.width + "  height " + pbm.height;
				_log.text += "\n\n" + pbm._log;

			}
			*/
		]]>
	</fx:Script>
	
	
	<s:Button x="69" y="67" label="load mesh .data" click="importMesh()"/>
	<s:TextArea x="69" y="110" width="482" height="450" id="_log"/>
	<mx:Image x="582" y="110" id="_img"/>
</s:Application>